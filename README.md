# Лабораторна робота №7
## Тема: Синхронізація потоків виконання
## Виконав(-ли): Ковальчук Станіслав, Сухоручкін Гліб, Янович Марія і Ястремський Богдан
---
## Аналіз роботи (п. 4.1-4.2):
### 4.1
Найбільший файл(найперший в масиві) оброблявся більше всіх, оскільки треба більше часу на обробку. Тож 1 "слабке місце" — розмір файлу. 2 "слабке місце" — к-сть тредів, за основу було взято систему "1 файл - 1 тред", що є найбільш логічною і доцільною, бо жоден тред не перевантажиться і не буде ініціалізований просто так.
### 4.2
Для перевірки даної частини роботи достатньо прибрати всі "тредові штучки" і в коді замінити filePath на масив filePaths з різних шляхів, і пройтись циклом по заданому масиву. Очевидно, що статистика не буде відрізнятися, бо кожен тред синхронізований і має свою зону відповідальності, проте всі файли обробляться швидше
## Контрольні питання:
### 1. Чим потік вводу-виводу відрізняється від потоку виконання?
Потік вводу-виводу (I/O) у Java відрізняється від потоку виконання основним чином в тому, що він призначений для обробки введених або виведених даних, тоді як потік виконання відповідає за сам процес виконання програми.

1. **Потік вводу-виводу (I/O)**:
   - Призначення: Операції зчитування та запису даних з інших джерел (наприклад, клавіатури, файлів, мережі тощо).
   - Робота: Ці потоки використовуються для передачі даних між програмою та зовнішнім середовищем.
   - Приклади: `InputStream`, `OutputStream`, `Reader`, `Writer` та їхні підкласи.

2. **Потік виконання**:
   - Призначення: Управління послідовністю виконання операцій в програмі.
   - Робота: Цей потік визначає порядок виконання операцій, включаючи виклики методів, операції умовної логіки, цикли тощо.
   - Приклади: Основний потік виконання програми у Java, який починається з методу `main`, а також можливі додаткові потоки, створені вручну або за допомогою бібліотеки `java.util.concurrent`.

Отже, потік вводу-виводу відповідає за обмін даними, тоді як потік виконання визначає послідовність виконання операцій у програмі.
### 2. В яких випадках та яким чином слід синхронізовувати потоки виконання при доступі до спільних ресурсів?
Потреба у синхронізації потоків виникає тоді, коли декілька потоків мають доступ до спільних ресурсів (наприклад, змінної, об'єкту чи файла) та можуть виконувати одночасні операції з цими ресурсами. Без синхронізації можуть виникати проблеми з конкурентним доступом, які можуть призводити до неправильної роботи програми або навіть до помилок виконання.

Ось декілька сценаріїв, коли слід синхронізувати потоки виконання:

1. **Коли потоки мають доступ до спільної змінної**:
   - Використання ключового слова `synchronized` для методів або блоків коду, які працюють з цією змінною.
   - Використання моніторів або блокування для запобігання одночасному доступу до змінної з різних потоків.

```java
public synchronized void synchronizedMethod() {
    // Код, який працює зі спільною змінною
}

// Або використання synchronized блоку
synchronized (sharedObject) {
    // Код, який працює зі спільним об'єктом sharedObject
}
```

2. **Коли потрібно уникнути гонки за ресурсами**:
   - Використання Lock-об'єктів з пакету `java.util.concurrent.locks`, які надають більш гнучкі можливості для синхронізації та управління блокуванням.
   - Використання умовних затримок (`Condition`) для керування порядком виконання потоків.

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class SharedResource {
    private final Lock lock = new ReentrantLock();

    public void accessResource() {
        lock.lock();
        try {
            // Код, який працює зі спільним ресурсом
        } finally {
            lock.unlock();
        }
    }
}
```

3. **Коли потоки працюють з колекціями даних**:
   - Використання `Collections.synchronizedXXX` для отримання синхронізованих версій колекцій, таких як `List`, `Map` та інші.

```java
List<String> synchronizedList = Collections.synchronizedList(new ArrayList<>());
Map<String, Integer> synchronizedMap = Collections.synchronizedMap(new HashMap<>());

// Доступ до колекцій потрібно здійснювати в межах synchronized блоку
synchronized (synchronizedList) {
    // Операції з synchronizedList
}

synchronized (synchronizedMap) {
    // Операції з synchronizedMap
}
```

Синхронізація потоків виконання важлива для запобігання ситуаціям, коли одночасні зміни даних можуть призводити до некоректної роботи програми або до втрати даних. Однак варто пам'ятати, що занадто інтенсивне використання синхронізації може призводити до затримок у виконанні програми, тому варто збалансувати необхідність синхронізації з продуктивністю програми.

### 3. Що таке блокуючий і неблокуючий ввід-вивід? 
Блокуючий і неблокуючий ввід-вивід (Blocking vs Non-blocking I/O) - це два різних підходи до роботи з потоками вводу-виводу в програмуванні.

1. **Блокуючий ввід-вивід (Blocking I/O)**:
   - У блокуючому ввіді-виводі операції вводу-виводу можуть заблокувати виконання програми до тих пір, поки операція не буде завершена.
   - Наприклад, якщо програма чекає на отримання даних з мережі через блокуючий потік вводу-виводу, вона може призупинити своє виконання, доки дані не будуть доступні або передані.

2. **Неблокуючий ввід-вивід (Non-blocking I/O)**:
   - У неблокуючому ввіді-виводі операції вводу-виводу не блокують виконання програми. Якщо операція не може бути виконана негайно (наприклад, даних немає на вході або вихідний канал не готовий для приймання даних), програма не призупиняє свою роботу, а продовжує виконання інших дій або чекає з іншими ресурсами.

Важливо враховувати, що кожен підхід має свої переваги та недоліки і підходить для різних сценаріїв використання:

- **Блокуючий ввід-вивід** зазвичай просте у використанні, оскільки операції блокуються до завершення, що дозволяє зручно виконувати послідовні дії.
- **Неблокуючий ввід-вивід** дозволяє програмі ефективно використовувати час очікування, не застосовуючи блокування та чекання. Це особливо корисно у високонавантажених системах, де необхідно мінімізувати простій та максимізувати використання ресурсів.

Зазвичай вибір між цими двома підходами залежить від конкретного завдання, вимог продукту та архітектурних рішень.
### 4. Що таке критична секція, м’ютекс, монітор?
**Критична секція**, **м'ютекс** і **монітор** - це поняття з області багатопотокового програмування, які використовуються для синхронізації доступу до спільних ресурсів між потоками.

1. **Критична секція**:
   - Це частина коду, яка працює з спільними ресурсами і вимагає синхронізації для запобігання гонці за даними.
   - У критичній секції потік блокується виключно для інших потоків, які намагаються отримати доступ до того ж ресурсу, поки перший потік не завершить своє виконання у цій секції.
   - Критичні секції допомагають уникнути некоректних даних або конфліктів при одночасному доступі до спільних ресурсів.

2. **М'ютекс** (Mutual Exclusion):
   - Це механізм синхронізації, який дозволяє лише одному потоку одночасно виконувати код у критичній секції.
   - Поток, який перший отримує м'ютекс (блокує його), має можливість виконати код у критичній секції, після чого він звільняє м'ютекс для інших потоків.
   - М'ютекси можуть бути реалізовані як частина операційної системи або як структура даних у програмі.

3. **Монітор**:
   - Монітор є абстракцією високого рівня, яка об'єднує деякі дії з м'ютексом та умовними затримками для керування доступом до критичних секцій.
   - Монітор дозволяє визначити, які методи або фрагменти коду є критичними, і автоматично управляє м'ютексами для їх синхронізації.
   - Монітори часто використовуються у вищорівневих мовах програмування для зручності роботи з багатопотоковими операціями.

Усі ці поняття використовуються для забезпечення правильної та безпечної роботи багатопотокових програм, де декілька потоків може конкурувати за доступ до обмежених ресурсів. Вони допомагають уникнути ситуацій гонки за даними та забезпечують взаємовиключний доступ до критичних ділянок коду.
### 5. Які є переваги/недоліки явного блокування (interface Lock) у порівнянні використанням синхронних секцій (synchronized)?
Використання явного блокування (за допомогою інтерфейсу `Lock` і його реалізацій, таких як `ReentrantLock`) та синхронних секцій (за допомогою ключового слова `synchronized`) є двома способами синхронізації потоків у Java. Кожен з цих підходів має свої переваги та недоліки:

### Переваги явного блокування (Lock):

1. **Гнучкість**:
   - `Lock` надає більшу гнучкість у порівнянні з `synchronized`. Наприклад, ви можете використовувати `tryLock()`, щоб намагатися заблокувати м'ютекс без очікування, або встановлювати час очікування за допомогою `tryLock(long time, TimeUnit unit)`.
   - Також є можливість використовувати рекурсивні блокування з `ReentrantLock`, що означає, що потік може знову заблокувати м'ютекс, який він вже утримує.

2. **Неблокуюча спроба отримання блокування**:
   - Метод `tryLock()` дозволяє намагатися отримати блокування без очікування, що може бути корисним у деяких ситуаціях, де необхідно уникати блокування потоку.

3. **Управління взаємочеканням**:
   - Використання методів `lockInterruptibly()` і `await()` з `Condition` дає можливість кращого управління взаємочеканням та обробки переривання потоків.

### Недоліки явного блокування (Lock):

1. **Більше джерело помилок**:
   - При використанні `Lock` потрібно бути обережним, оскільки можна забути звільнити блокування, що призведе до потенційних проблем зі збійністю програми або до витоку ресурсів.

2. **Більше коду**:
   - Виразне блокування за допомогою `Lock` часто вимагає більшого обсягу коду, ніж використання `synchronized`.

### Переваги синхронних секцій (synchronized):

1. **Простота використання**:
   - Ключове слово `synchronized` надає простий та зручний спосіб синхронізувати доступ до критичних секцій коду.

2. **Автоматичне звільнення блокування**:
   - При використанні `synchronized` блокування автоматично звільняється при виході з критичної секції або при завершенні виконання методу.

### Недоліки синхронних секцій (synchronized):

1. **Обмежена гнучкість**:
   - `synchronized` не надає такої великої гнучкості та можливостей управління, як `Lock`.
  
2. **Небезпека блокування потоку**:
   - Виразне блокування потоку за допомогою `synchronized` може призводити до блокування потоку надто довго, якщо інший потік не звільнює блокування.

Обираючи між `Lock` та `synchronized`, варто враховувати конкретні потреби програми. Якщо вам потрібна більша гнучкість та управління блокуванням, `Lock` може бути кращим варіантом. Однак, якщо ви працюєте над простими сценаріями та бажаєте зручнішого синтаксису, `synchronized` може бути зручнішим вибором.
### 6. Що означають терміни thread-safe та fail-fast для колекцій?
Терміни "thread-safe" та "fail-fast" стосуються колекцій в Java і вказують на їхню поведінку в багатопотоковому середовищі.

1. **Thread-Safe (безпечні для потоків)**:
   - Колекція вважається thread-safe, якщо вона може безпечно використовуватися в багатопотоковому середовищі без необхідності додаткових синхронізацій з боку користувача.
   - Ознаки thread-safe колекції включають гарантовану коректність роботи навіть при одночасному доступі з багатьох потоків, а також уникнення гонок за даними і інших конкурентних проблем.

2. **Fail-Fast**:
   - Fail-fast означає, що колекція реагує на структурні зміни (наприклад, додавання, видалення елементів) під час ітерації через неї, викидаючи виняток `ConcurrentModificationException`.
   - Це зроблено для того, щоб попередити некоректне використання колекцій у багатопотоковому середовищі, коли один потік змінює колекцію, а інший паралельно її ітерує.
   - Fail-fast підходить для виявлення помилок під час розробки та вказує на потенційні проблеми в коді, пов'язані з некоректним паралельним доступом до колекцій.

Отже, thread-safe колекції дозволяють безпечно працювати з даними в багатопотоковому середовищі, уникнувши багатьох звичайних проблем конкурентного доступу. Fail-fast механізм нагадує розробникам про важливість коректного використання колекцій в многопоточних програмах та допомагає виявляти помилки з ними швидше.
---
## Висновки:
У ході цієї лаборатоної роботи, ми дізналися повторили потоки виконання, і їх синхронізацію
